<#@ template language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ assembly name="$(TargetDir)\MHW-Template.dll" #>
<#@ parameter type="System.String" name="_namespace" #>
<#@ parameter type="System.String" name="className" #>
<#@ parameter type="MHW_Template.MhwStructData" name="structData" #>
<#@ import namespace="Microsoft.CSharp" #>
<#@ import namespace="System.Text.RegularExpressions" #>
<#@ import namespace="MHW_Template.Models" #>
using System.ComponentModel;
using MHW_Editor.Assets;
using MHW_Editor.Models;
using MHW_Template;
using MHW_Template.Models;

namespace <#= _namespace #> {
    public partial class <#= className #> {
        public const uint StructSize = <#= structData.size #>;
        public const ulong InitialOffset = <#= structData.offsetInitial #>;
        public const long EntryCountOffset = <#= structData.entryCountOffset #>;
        public const string EncryptionKey = <#= structData.encryptionKey == null ? "null" : $"\"{structData.encryptionKey}\"" #>;
        public override string UniqueId => $"<#= structData.uniqueIdFormula #>";
<#
    var compiler = new CSharpCodeProvider();
    var sortIndex = 50;

    foreach (var entry in structData.entries) {
        var accessLevel = entry.accessLevel;
        var name = Regex.Replace(entry.displayName, @"[^\w\d]+", "_");
        var typeString = compiler.GetTypeOutput(entry.type);
        string returnString;
        var setCast = "";
        var getCast = "";

        // Don't need now, but uncomment in the future if we need to override a generated property.
        if (accessLevel != "private") {
            accessLevel += " virtual";
        }

        if (entry.enumReturn == null) {
            returnString = typeString;
        } else {
            returnString = compiler.GetTypeOutput(entry.enumReturn);
            getCast = $"({returnString}) ";
            setCast = $"({typeString}) ";
        }
#>

        public const string <#= name #>_displayName = "<#= entry.displayName #>";
        public const int <#= name #>_sortIndex = <#= sortIndex #>;
        [SortOrder(<#= name #>_sortIndex)]
        [DisplayName(<#= name #>_displayName)]
<#
        if (entry.dataSourceType != null) {
#>
        [DataSource(DataSourceType.<#= entry.dataSourceType #>)]
<#
        } // End dataSource check.
#>
        <#= accessLevel #> <#= returnString #> <#= name #> {<# // Property definition. #>

            get => <#= getCast #>GetData<<#= typeString #>>(<#= entry.offset #>);<# // Getter. #>

<#
        if (!entry.readOnly) {
#>
            set {<# // Setter. #>

                if (<#= getCast #>GetData<<#= typeString #>>(<#= entry.offset #>) == <#= entry.valueString #>) return;<# // Do nothing if the value is the same. #>

                SetData(<#= entry.offset #>, <#= setCast #><#= entry.valueString #>, nameof(<#= name #>));
                OnPropertyChanged(nameof(Raw_Data));
                OnPropertyChanged(nameof(<#= name #>));
<#
            if (entry.dataSourceType != null) {
#>
                OnPropertyChanged(nameof(<#= name #>_button));
<#
            } // End extra OnPropertyChanged/dataSourceType check.

            if (entry.extraOnPropertyChanged != null) {
                foreach (var propertyToChange in entry.extraOnPropertyChanged) {
                    var propertyToChangeName = Regex.Replace(propertyToChange, @"[^\w\d]+", "_");
#>
                OnPropertyChanged(nameof(<#= propertyToChangeName #>));
<#
                }
            } // End extra OnPropertyChanged/extraOnPropertyChanged check.
#>
            }
<#
        } // End readOnly check.
#>
        }<# // End property block. #>

<#
        if (entry.dataSourceType != null) {
            string dataSourceLookup;

            switch (entry.dataSourceType) {
                case DataSourceType.Items:
                    dataSourceLookup = "DataHelper.itemData[MainWindow.locale]";
                    break;
                case DataSourceType.Skills:
                    dataSourceLookup = "DataHelper.skillData[MainWindow.locale]";
                    break;
                case DataSourceType.SkillDat:
                    dataSourceLookup = "MainWindow.skillDatLookup[MainWindow.locale]";
                    break;
                default:
                    throw new ArgumentOutOfRangeException();
            }
#>

        [SortOrder(<#= name #>_sortIndex)]
        [DisplayName(<#= name #>_displayName)]
        [CustomSorter(typeof(<#= entry.dataSourceCustomSorter #>))]
        public string <#= name #>_button => <#= dataSourceLookup #>.TryGet((ushort) <#= name #>, IdNamePair.Unknown((ushort) <#= name #>)).ToString();
<#
        } // End data source / button generation check.

        sortIndex += 50;
    } // End loop.
#>

        public const int lastSortIndex = <#= sortIndex #>;
    }<# // End class. #>

}